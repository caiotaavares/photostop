#ifndef IMAGEMANAGEMENT_H
#define IMAGEMANAGEMENT_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

#include "structs.h"

using namespace std;

Image read_image(const char *filename) {
    int row = 0, col = 0, numrows = 0, numcols = 0, maxval = 0;
    ifstream infile(filename);
    stringstream ss;
    string inputLine = "";

    // First line: version
    getline(infile, inputLine);
    if (inputLine.compare("P6") != 0) {
        cerr << "Version error" << endl;
    } else {
        cout << "Version: " << inputLine << endl;
    }

    // Store version in Image structure
    string version = inputLine;
    cout << "Version: " << version << endl;

    // Second line: comment
    getline(infile, inputLine);
    cout << "Comment: " << inputLine << endl;

    // Store comment in Image structure
    string comment = inputLine;

    // Continue with a stringstream
    ss << infile.rdbuf();
    // Third line: size
    ss >> numcols >> numrows;
    cout << numcols << " columns and " << numrows << " rows" << endl;

    // Fourth line: maximum value
    ss >> maxval;
    cout << "Maximum value: " << maxval << endl;

    // Create a 2D array for RGB channels
    Array **array = new Array*[numrows];
    for (row = 0; row < numrows; ++row) {
        array[row] = new Array[numcols]; // RGB channels
        for (col = 0; col < numcols; ++col) {
            unsigned char r, g, b;
            ss.read(reinterpret_cast<char*>(&r), sizeof(unsigned char));
            ss.read(reinterpret_cast<char*>(&g), sizeof(unsigned char));
            ss.read(reinterpret_cast<char*>(&b), sizeof(unsigned char));
            array[row][col].R = static_cast<int>(r);
            array[row][col].G = static_cast<int>(g);
            array[row][col].B = static_cast<int>(b);
        }
    }

    Image image;
    image.version = version;
    image.comment = comment;
    image.array = array;
    image.numrows = numrows;
    image.numcols = numcols;
    image.maxval = maxval;

    return image;
}

void savePPM(const char *filename, const Image& image) {
    ofstream outfile(filename, ios::binary);
    if (!outfile) {
        cerr << "Error opening file " << filename << " for writing." << endl;
        return;
    }

    // Write PPM header
    outfile << "P6" << endl;
    outfile << "# Image generated by the program" << endl;
    outfile << image.numcols << " " << image.numrows << endl;
    outfile << image.maxval << endl;

    // Write the RGB pixels
    for (int row = 0; row < image.numrows; ++row) {
        for (int col = 0; col < image.numcols; ++col) {
            unsigned char r = static_cast<unsigned char>(image.array[row][col].R);
            unsigned char g = static_cast<unsigned char>(image.array[row][col].G);
            unsigned char b = static_cast<unsigned char>(image.array[row][col].B);
            outfile.write(reinterpret_cast<char*>(&r), sizeof(unsigned char));
            outfile.write(reinterpret_cast<char*>(&g), sizeof(unsigned char));
            outfile.write(reinterpret_cast<char*>(&b), sizeof(unsigned char));
        }
    }

    outfile.close();
}

void savePPMP3(const char* filename, const Image& image) {
    ofstream outfile(filename);
    if (!outfile) {
        cerr << "Error opening file " << filename << " for writing." << endl;
        return;
    }

    // Write PPM header
    outfile << "P3" << endl;
    outfile << "# Image generated by the program" << endl;
    outfile << image.numcols << " " << image.numrows << endl;
    outfile << image.maxval << endl;

    // Write the RGB pixels
    for (int row = 0; row < image.numrows; ++row) {
        for (int col = 0; col < image.numcols; ++col) {
            outfile << image.array[row][col].R << " ";
            outfile << image.array[row][col].G << " ";
            outfile << image.array[row][col].B << " ";
        }
        outfile << endl;
    }

    outfile.close();
}

#endif // IMAGEMANAGEMENT_H
